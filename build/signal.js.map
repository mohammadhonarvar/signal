{
  "version": 3,
  "sources": ["../node_modules/@alwatr/logger/src/global-alwatr.ts", "../node_modules/@alwatr/logger/src/logger.ts", "../src/common.ts", "../src/context-signal.ts", "../src/simple-signal.ts"],
  "sourcesContent": ["import type {} from '@alwatr/type/global.js';\n\nif (globalThis.Alwatr == null) {\n  globalThis.Alwatr = {\n    registeredList: [],\n  };\n}\n\ntry {\n  _ALWATR_VERSION_;\n}\ncatch {\n  globalThis._ALWATR_VERSION_ = 'ERROR';\n  console.warn('!! SCRIPTS LOADED OUTSIDE OF ALWATR BUILD ENVIRONMENT !!');\n}\n\nif (Alwatr.registeredList == null) {\n  Alwatr.registeredList = [];\n}\n\nexport const globalAlwatr = Alwatr;\n", "import {globalAlwatr} from './global-alwatr.js';\n\nimport type {AlwatrLogger} from './type.js';\n\nexport {type AlwatrLogger, globalAlwatr};\n\nglobalAlwatr.registeredList.push({\n  name: '@alwatr/logger',\n  version: _ALWATR_VERSION_,\n});\n\nexport const NODE_MODE = typeof process !== 'undefined';\nexport const DEV_MODE = NODE_MODE\n  ? process.env.ALWATR_DEBUG === '1'\n  : globalThis.localStorage?.getItem('alwatrDebug') === '1';\n\n/**\n * Color list storage for logger.\n */\nconst colorList = NODE_MODE\n  ? ['0;36', '0;35', '0;34', '0;33', '0;32'] // red and white omitted\n  : [\n    '#35b997',\n    '#f05561',\n    '#ee224a',\n    '#91c13e',\n    '#22af4b',\n    '#f0e995',\n    '#0fe995',\n    '#0f89ca',\n    '#08b9a5',\n    '#fee851',\n    '#ee573d',\n    '#f9df30',\n    '#1da2dc',\n    '#f05123',\n    '#ee2524',\n  ];\n\nlet _colorIndex = 0;\nconst _getNextColor = (): string => {\n  const color = colorList[_colorIndex];\n  _colorIndex++;\n  if (_colorIndex >= colorList.length) {\n    _colorIndex = 0;\n  }\n  return color;\n};\n\nconst _style = {\n  scope: NODE_MODE ? '\\x1b[{{color}}m' : 'color: {{color}};',\n  reset: NODE_MODE ? '\\x1b[0m' : 'color: inherit;',\n};\n\nconst _keySection = NODE_MODE ? '%s%s%s' : '%c%s%c';\n\nconst _sanitizeDomain = (domain: string): string => {\n  domain = domain.trim();\n  const first = domain.charAt(0);\n  if (first !== '[' && first !== '{' && first !== '<') {\n    domain = '[' + domain + ']';\n  }\n  return domain;\n};\n\n/**\n * Create a logger function for fancy console debug with custom scope.\n *\n * - **color** is optional and automatically select from internal fancy color list.\n * - **debug** is optional and automatically detect from localStorage `ALWATR_DEBUG` item or `process.env.ALWATR_DEBUG`\n *\n * Example:\n *\n * ```ts\n * import {createLogger} from 'https://esm.run/@alwatr/logger';\n * const logger = createLogger('logger/demo');\n * ```\n */\nexport const createLogger = (domain: string, devMode = DEV_MODE): AlwatrLogger => {\n  const color = _getNextColor();\n  const styleScope = _style.scope.replaceAll('{{color}}', color);\n  domain = _sanitizeDomain(domain);\n\n  /**\n   * Required logger object, accident, error always reported even when the devMode is false.\n   */\n  const requiredItems = {\n    devMode,\n    domain,\n\n    accident: NODE_MODE\n      ? console.warn.bind(console, `${styleScope}⚠️\\n%s\\x1b[33m.%s() Accident \\`%s\\` %s!${_style.reset}`, domain)\n      : console.warn.bind(console, '%c%s%c.%s() Accident `%s` %s!', styleScope, domain, _style.reset),\n\n    error: NODE_MODE\n      ? console.error.bind(console, `${styleScope}❌\\n%s\\x1b[31m.%s() Error \\`%s\\`${_style.reset}\\n`, domain)\n      : console.error.bind(console, '%c%s%c.%s() Error `%s`\\n', styleScope, domain, _style.reset),\n  } as const;\n\n  if (!devMode) {\n    return requiredItems;\n  }\n  // else\n  return {\n    ...requiredItems,\n\n    logProperty: console.debug.bind(console, _keySection + '.%s = %o;', styleScope, domain, _style.reset),\n\n    logMethod: console.debug.bind(console, _keySection + '.%s();', styleScope, domain, _style.reset),\n\n    logModule: console.debug.bind(console, _keySection + '/%s.js;', styleScope, domain, _style.reset),\n\n    logMethodArgs: console.debug.bind(console, _keySection + '.%s(%o);', styleScope, domain, _style.reset),\n\n    logMethodFull: console.debug.bind(console, _keySection + '.%s(%o) => %o', styleScope, domain, _style.reset),\n\n    logOther: console.debug.bind(console, _keySection, styleScope, domain, _style.reset),\n\n    incident: NODE_MODE\n      ? console.log.bind(console, `${styleScope}🚸\\n%s${_style.reset}.%s() Incident \\`%s\\` %s!${_style.reset}`, domain)\n      : console.log.bind(console, '%c%s%c.%s() Incident `%s` %s!', styleScope, domain, 'color: orange;'),\n\n    time: (label: string) => console.time(domain + '.' + label + ' duration time'),\n    timeEnd: (label: string) => console.timeEnd(domain + '.' + label + ' duration time'),\n  } as const;\n};\n", "import {globalAlwatr} from '@alwatr/logger/logger.js';\n\nimport type {SignalStorage} from './type.js';\n\nglobalAlwatr.registeredList.push({\n  name: 'signal',\n  version: '1.0.0',\n});\n\nexport const debounceTimeout = 5;\n\n/**\n * Signal stack database.\n */\nexport const _signalStorage: SignalStorage = {};\n\nexport const _actionTarget: EventTarget | Element =\n  'eventTarget' in window ? new EventTarget() : document.createElement('span');\n\nexport function removeSignal(signalId: keyof typeof _signalStorage, prune = false): void {\n  const signal = _signalStorage[signalId];\n  if (signal == null) return;\n\n  for (const listener of signal.listenerList) {\n    _actionTarget.removeEventListener(\n      signalId as string,\n      listener.callback as EventListenerOrEventListenerObject,\n    );\n  }\n\n  if (prune) {\n    delete _signalStorage[signalId];\n    return;\n  }\n\n  signal.listenerList.length = 0;\n}\n\n/**\n * A function to empty signal object\n * @function resetSignalObject\n * @returns {void} void\n */\nexport function resetSignalObject(): void {\n  const signalIds = Object.keys(_signalStorage);\n\n  for (const signalId of signalIds) {\n    removeSignal((signalId), true);\n  }\n}\n", "import {createLogger} from '@alwatr/logger/logger.js';\n\nimport {_actionTarget, _signalStorage, debounceTimeout} from './common.js';\n\nimport type {ContextSignalDispatchOptions, ContextSignalObject} from './type.js';\n\nconst logger = createLogger('context-signal');\n\n/**\n * Listener `id`\n */\nlet _lastContextSignalListenerAutoId = 0;\n\nconst _getContextSignalObject = <T>() => <K extends keyof T = keyof T>(\n  signalId: K,\n): ContextSignalObject<T[K]> => {\n  let signal = _signalStorage[signalId] as ContextSignalObject<T[K]> | undefined;\n  if (signal == null) {\n    signal = _signalStorage[signalId as string] = {\n      id: signalId as string,\n      disabled: false,\n      debounced: false,\n      detail: undefined,\n      listenerList: [],\n      firstDispatchedDone: false,\n    };\n  }\n\n  return signal;\n};\n\n/**\n *\n * Example:\n *\n * ```ts\n * setContextSignalValue<ContentType>('content-change', { key: 5 });\n * ```\n */\nexport const setContextSignalValue = <T extends object>() => <K extends keyof T = keyof T>(\n  signalId: K,\n  value: Partial<T[K]>,\n  replaceAll = false,\n): ContextSignalObject<T[K]> => {\n  logger.logMethodArgs?.('setContextSignalValue', {signalId, value, replaceAll});\n\n  const signal = _getContextSignalObject<T>()(signalId);\n  if (signal.detail === undefined || replaceAll) {\n    signal.detail = value as T[K];\n    return signal;\n  }\n\n  if (\n    typeof signal.detail === 'object' &&\n    !Array.isArray(signal.detail) &&\n    typeof value === 'object'\n  ) {\n    signal.detail = {...signal.detail, ...value};\n    return signal;\n  }\n\n  signal.detail = value as T[K];\n  return signal;\n};\n\n/**\n * Get current signal detail/value.\n *\n * Example:\n *\n * ```ts\n * const currentContent = getContextSignalValue<ContentType>('content-change');\n * ```\n */\nexport const getContextSignalValue = <T extends object>() => <K extends keyof T = keyof T>(signalId: K): T[K] | undefined => {\n  return _getContextSignalObject<T>()(signalId).detail;\n};\n\n\nexport function contextDispatch<T extends object>() {\n  return <K extends keyof T = keyof T>(\n    signalId: K,\n    value: T[K],\n    options: Partial<ContextSignalDispatchOptions> = {}): void => {\n    options.debounce ??= 'NextCycle';\n    options.scopeName ??= 'unknown';\n    options.replaceAll ??= false;\n\n    logger.logMethodArgs?.('contextDispatch', {signalId, value, options});\n\n    const signal = setContextSignalValue<T>()(signalId, value, options.replaceAll);\n    signal.firstDispatchedDone = true;\n\n    if (signal.disabled) return;\n\n    const dispatchEvent = (): void => {\n      _actionTarget.dispatchEvent(\n          new CustomEvent(signalId as string, {\n            detail: value,\n          }),\n      );\n    };\n\n    if (options.debounce === 'No') {\n      dispatchEvent();\n      return;\n    }\n\n    // else\n    if (options.debounce === 'NextCycle') {\n      setTimeout(dispatchEvent, 0);\n      return;\n    }\n\n    // else\n    if (signal.debounced === true) {\n      return; // last dispatch in progress.\n    }\n\n    // else\n    signal.debounced = true;\n  options.debounce === 'AnimationFrame'\n    ? requestAnimationFrame(dispatchEvent)\n    : setTimeout(dispatchEvent, debounceTimeout);\n  };\n}\n\nexport function contextEditionDispatch<T extends object>() {\n  return <K extends keyof T = keyof T>(\n    signalId: K,\n    value: Partial<T[K]>,\n    options: Partial<ContextSignalDispatchOptions> = {}): void => {\n    logger.logMethodArgs?.('contextEditionDispatch', {signalId, value, options});\n\n    const signal = _getContextSignalObject<T>()(signalId);\n    if (!signal.firstDispatchedDone) {\n      console.warn(`Use \\`contextDispatch\\` for ${signalId as string} , then this function can run`);\n      return;\n    }\n\n    contextDispatch<T>()(signalId, value as T[K], options);\n  };\n}\n\n\nexport function onContextDispatch<T extends object>() {\n  return <K extends keyof T = keyof T>(\n    signalId: K,\n    callback: (detail: T[K]) => void | Promise<void>,\n    options: { preserved?: boolean, runAsLatest?: boolean; once?: boolean } = {}): number => {\n    options.preserved ??= true;\n    logger.logMethodArgs?.('onContextDispatch', {signalId, callback, options});\n\n    const signal = _getContextSignalObject<T>()(signalId);\n    if (signal.disabled) return _lastContextSignalListenerAutoId;\n\n    const listenerCallback = (event: CustomEvent<T[typeof signalId]>): void | Promise<void> => {\n      try {\n        callback(event.detail);\n      }\n      catch (err) {\n        logger.error('onContextDispatch', 'call_signal_callback_failed', err, {\n          signalId: signal.id,\n        });\n      }\n    };\n\n    signal.listenerList.push({\n      id: ++_lastContextSignalListenerAutoId,\n      signalId: signal.id,\n      once: options.once ?? false,\n      callback: listenerCallback,\n    });\n\n    _actionTarget.addEventListener(\n      signalId as string,\n      ((event: CustomEvent) => {\n        if (options.runAsLatest) {\n          setTimeout(() => {\n            listenerCallback(event);\n          }, 0);\n        }\n        else {\n          listenerCallback(event);\n        }\n      }) as EventListener,\n      {once: options.once},\n    );\n\n    if (options.preserved && signal.firstDispatchedDone) {\n      setTimeout(listenerCallback, 0, signal.detail);\n    }\n\n    return _lastContextSignalListenerAutoId;\n  };\n}\n\nexport function removeOnContextDispatch<T extends object>() {\n  return <K extends keyof T = keyof T>(signalId: K, listenerId: number): void => {\n    const signal = _signalStorage[signalId as string];\n    if (signal == null) return;\n\n    const index = signal.listenerList.findIndex((item) => item.id === listenerId);\n    if (index > -1) {\n      _actionTarget.removeEventListener(\n        signalId as string,\n        signal.listenerList[index].callback as EventListenerOrEventListenerObject,\n      );\n    }\n  };\n}\n\n/**\n * A function to trigger actions that we need, it's async\n * @function firstContextDispatch\n * @returns {Promise<void>} promise of void\n */\nexport function firstContextDispatch<T extends object>() {\n  return <K extends keyof T = keyof T>(signalId: K, conditionFn?: (detail: ContextSignalObject<T[K]>['detail']) => boolean): Promise<void> => {\n    let canRemoveOnDispatch = false;\n\n    return new Promise((resolve) => {\n      const listenerId = onContextDispatch<T>()(signalId, (detail) => {\n        if (typeof conditionFn === 'function') {\n          const result = conditionFn(detail as ContextSignalObject<T[K]>['detail']);\n          if (result === true) {\n            canRemoveOnDispatch = true;\n            resolve();\n          }\n        }\n        else {\n          resolve();\n        }\n\n        if (canRemoveOnDispatch) {\n          removeOnContextDispatch<T>()(signalId, listenerId);\n        }\n      });\n    });\n  };\n}\n", "import {createLogger} from '@alwatr/logger/logger.js';\n\nimport {_actionTarget, _signalStorage, debounceTimeout} from './common.js';\n\nimport type {DispatchOptions, SignalObject} from './type.js';\n\nconst logger = createLogger('simple-signal');\n\n/**\n * Listener `id`\n */\nlet _lastListenerAutoId = 0;\n\nconst _getSimpleSignalObject = <T>(\n  signalId: T,\n): SignalObject => {\n  let signal = _signalStorage[signalId] as SignalObject | undefined;\n  if (signal == null) {\n    signal = _signalStorage[signalId as string] = {\n      id: signalId as string,\n      disabled: false,\n      debounced: false,\n      listenerList: [],\n      firstDispatchedDone: false,\n    };\n  }\n\n  return signal;\n};\n\n\nexport function dispatch<T>(\n    signalId: T,\n    options: Partial<DispatchOptions> = {}): void {\n  options.debounce ??= 'NextCycle';\n\n  logger.logMethodArgs?.('dispatch', {signalId, options});\n\n  const signal = _getSimpleSignalObject(signalId);\n  signal.firstDispatchedDone = true;\n\n  if (signal.disabled) return;\n\n  const dispatchEvent = (): void => {\n    _actionTarget.dispatchEvent(\n        new CustomEvent(signalId as string),\n    );\n  };\n\n  if (options.debounce === 'No') {\n    dispatchEvent();\n    return;\n  }\n\n  // else\n  if (options.debounce === 'NextCycle') {\n    setTimeout(dispatchEvent, 0);\n    return;\n  }\n\n  // else\n  if (signal.debounced === true) {\n    return; // last dispatch in progress.\n  }\n\n  // else\n  signal.debounced = true;\n  options.debounce === 'AnimationFrame'\n    ? requestAnimationFrame(dispatchEvent)\n    : setTimeout(dispatchEvent, debounceTimeout);\n}\n\nexport function onDispatch<T>(\n    signalId: T,\n    callback: () => void | Promise<void>,\n    options: { preserved?: boolean, runAsLatest?: boolean; once?: boolean } = {}): number {\n  options.preserved ??= true;\n  logger.logMethodArgs?.('onDispatch', {signalId, callback, options});\n\n  const signal = _getSimpleSignalObject(signalId);\n  if (signal.disabled) return _lastListenerAutoId;\n\n  const listenerCallback = (): void | Promise<void> => {\n    try {\n      callback();\n    }\n    catch (err) {\n      logger.error('onContextDispatch', 'call_signal_callback_failed', err, {\n        signalId: signal.id,\n      });\n    }\n  };\n\n  signal.listenerList.push({\n    id: ++_lastListenerAutoId,\n    signalId: signal.id,\n    once: options.once ?? false,\n    callback: listenerCallback,\n  });\n\n  _actionTarget.addEventListener(\n    signalId as string,\n    (() => {\n      if (options.runAsLatest) {\n        setTimeout(() => {\n          listenerCallback();\n        }, 0);\n      }\n      else {\n        listenerCallback();\n      }\n    }) as EventListener,\n    {once: options.once},\n  );\n\n  if (options.preserved) {\n    setTimeout(callback, 0);\n  }\n\n  return _lastListenerAutoId;\n}\n\nexport function removeOnDispatch<T>(signalId: T, listenerId: number): void {\n  const signal = _signalStorage[signalId as string];\n  if (signal == null) return;\n\n  const index = signal.listenerList.findIndex((item) => item.id === listenerId);\n  if (index > -1) {\n    _actionTarget.removeEventListener(\n      signalId as string,\n      signal.listenerList[index].callback as EventListenerOrEventListenerObject,\n    );\n  }\n}\n\n/**\n * A function to trigger actions that we need, it's async\n * @function firstContextDispatch\n * @returns {Promise<void>} promise of void\n */\nexport function firstDispatch<T>(signalId: T): Promise<void> {\n  return new Promise((resolve) => {\n    const listenerId = onDispatch<T>(signalId, () => {\n      resolve();\n      removeOnDispatch(signalId, listenerId);\n    });\n  });\n}\n"],
  "mappings": "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",
  "names": ["globalAlwatr", "globalAlwatr", "NODE_MODE", "_a", "DEV_MODE", "colorList", "_colorIndex", "_getNextColor", "color", "_style", "_keySection", "_sanitizeDomain", "domain", "first", "createLogger", "devMode", "styleScope", "requiredItems", "label", "globalAlwatr", "debounceTimeout", "_signalStorage", "_actionTarget", "removeSignal", "signalId", "prune", "signal", "listener", "resetSignalObject", "signalIds", "logger", "createLogger", "_lastContextSignalListenerAutoId", "_getContextSignalObject", "signalId", "signal", "_signalStorage", "setContextSignalValue", "value", "replaceAll", "_a", "getContextSignalValue", "contextDispatch", "options", "_b", "_c", "_d", "dispatchEvent", "_actionTarget", "debounceTimeout", "contextEditionDispatch", "onContextDispatch", "callback", "listenerCallback", "event", "err", "removeOnContextDispatch", "listenerId", "index", "item", "firstContextDispatch", "conditionFn", "canRemoveOnDispatch", "resolve", "detail", "logger", "createLogger", "_lastListenerAutoId", "_getSimpleSignalObject", "signalId", "signal", "_signalStorage", "dispatch", "options", "_a", "_b", "dispatchEvent", "_actionTarget", "debounceTimeout", "onDispatch", "callback", "_c", "listenerCallback", "err", "removeOnDispatch", "listenerId", "index", "item", "firstDispatch", "resolve"]
}
